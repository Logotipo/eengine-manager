#include <stm32f10x_tim.h>
#include <stm32f10x_gpio.h>
#include <stm32f10x_rcc.h>
#include "settings.h"

const uint8_t encoderMap[256] = {
  0xFF,0x38,0x28,0x37,0x18,0xFF,0x27,0x34,0x08,0x39,0xFF,0xFF,0x17,0xFF,0x24,0x0D,
  0x78,0xFF,0x29,0x36,0xFF,0xFF,0xFF,0x35,0x07,0xFF,0xFF,0xFF,0x14,0x13,0x7D,0x12,
  0x68,0x69,0xFF,0xFF,0x19,0x6A,0x26,0xFF,0xFF,0x3A,0xFF,0xFF,0xFF,0xFF,0x25,0x0E,
  0x77,0x76,0xFF,0xFF,0xFF,0x6B,0xFF,0xFF,0x04,0xFF,0x03,0xFF,0x6D,0x6C,0x02,0x01,
  0x58,0xFF,0x59,0xFF,0xFF,0xFF,0xFF,0x33,0x09,0x0A,0x5A,0xFF,0x16,0x0B,0xFF,0x0C,
  0xFF,0xFF,0x2A,0x2B,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x15,0xFF,0x7E,0x7F,
  0x67,0xFF,0x66,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x5B,0xFF,0xFF,0xFF,0xFF,0xFF,
  0x74,0x75,0xFF,0xFF,0x73,0xFF,0xFF,0xFF,0x5D,0x5E,0x5C,0xFF,0x72,0x5F,0x71,0x00,
  0x48,0x47,0xFF,0x44,0x49,0xFF,0xFF,0x1D,0xFF,0x46,0xFF,0x45,0xFF,0xFF,0x23,0x22,
  0x79,0xFF,0x7A,0xFF,0x4A,0xFF,0xFF,0x1E,0x06,0xFF,0x7B,0xFF,0xFF,0xFF,0x7C,0x11,
  0xFF,0xFF,0xFF,0x43,0x1A,0xFF,0x1B,0x1C,0xFF,0x3B,0xFF,0xFF,0xFF,0xFF,0xFF,0x0F,
  0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x05,0xFF,0xFF,0xFF,0x6E,0xFF,0x6F,0x10,
  0x57,0x54,0xFF,0x2D,0x56,0x55,0xFF,0x32,0xFF,0xFF,0xFF,0x2E,0xFF,0xFF,0xFF,0x21,
  0xFF,0x53,0xFF,0x2C,0x4B,0xFF,0xFF,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x20,
  0x64,0x3D,0x65,0x42,0xFF,0x3E,0xFF,0x31,0x63,0x3C,0xFF,0x2F,0xFF,0xFF,0xFF,0x30,
  0x4D,0x52,0x4E,0x41,0x4C,0x3F,0xFF,0x40,0x62,0x51,0x4F,0x50,0x61,0x60,0x70,0xFF };


extern double current_motor_speed;//rad/sec
extern double current_motor_angle;//rad
extern double motor_angle_offset;//rad
double last_current_motor_angle;//rad
  
extern uint8_t mainTimFlag;

void InitCheckSpeed(void){
	//enable clocking TIM2 and PORTB
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
	////////////////////////////////
	//configure PINs
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 |
								  GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
#if !STAND
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
#else
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; // pull up
#endif
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOB, &GPIO_InitStructure);
	////////////////
	//configure timer
	TIM_TimeBaseInitTypeDef TIM_StructInit;
	TIM_StructInit.TIM_Prescaler = 71;
	TIM_StructInit.TIM_Period = 1000;//~1,000kHz
	TIM_StructInit.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM1, &TIM_StructInit);
	TIM_ITConfig(TIM1, TIM_IT_Update, ENABLE);//enable iterrupt
	TIM_Cmd(TIM1, ENABLE);//enable timer
	/////////////////
}
#if SVPWM
void InitPWMTIMs(void){
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
	//configure PINs
	GPIO_InitTypeDef GPIO_InitStructure;
	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |
								  GPIO_Pin_6 | GPIO_Pin_7;
	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
	GPIO_Init(GPIOA, &GPIO_InitStructure);
	////////////////
	//configure timer
	TIM_TimeBaseInitTypeDef TIM_StructInit;
	TIM_StructInit.TIM_Prescaler = 11;
	TIM_StructInit.TIM_Period = 1000;//6,000kHz
	TIM_StructInit.TIM_CounterMode = TIM_CounterMode_Up;
	TIM_TimeBaseInit(TIM2, &TIM_StructInit);//TIM 2
	TIM_TimeBaseInit(TIM3, &TIM_StructInit);//TIM 3
	/////////////////
	//configure PWM
	TIM_OCInitTypeDef TIM_OCInitStructH;
	TIM_OCInitTypeDef TIM_OCInitStructL;
	TIM_OCStructInit(&TIM_OCInitStructH);
	TIM_OCStructInit(&TIM_OCInitStructL);
	
	TIM_OCInitStructH.TIM_OCMode = TIM_OCMode_PWM1;
	TIM_OCInitStructH.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructH.TIM_Pulse = 0;
	TIM_OCInitStructH.TIM_OCPolarity = TIM_OCPolarity_High;
	
	TIM_OCInitStructL.TIM_OCMode = TIM_OCMode_PWM1;
	TIM_OCInitStructL.TIM_OutputState = TIM_OutputState_Enable;
	TIM_OCInitStructL.TIM_Pulse = 0;
	TIM_OCInitStructL.TIM_OCPolarity = TIM_OCPolarity_Low;
	
	TIM_OC1Init(TIM2, &TIM_OCInitStructH);
	TIM_OC2Init(TIM2, &TIM_OCInitStructL);
	TIM_OC2Init(TIM2, &TIM_OCInitStructH);
	TIM_OC3Init(TIM2, &TIM_OCInitStructL);
	TIM_OC1Init(TIM3, &TIM_OCInitStructH);
	TIM_OC2Init(TIM3, &TIM_OCInitStructL);
	
	TIM_Cmd(TIM2, ENABLE);
	TIM_Cmd(TIM3, ENABLE);
}
#endif
void UpdateSpeedAndAngle(void){
	uint8_t abs_pos = encoderMap[GPIO_ReadInputData(GPIOB) & 0xFF];//get absolutely position from encoder
	current_motor_angle = abs_pos * (D_PI / ENCODER_STEPS_COUNT);//get rad angle
	current_motor_angle -= motor_angle_offset;
	if(current_motor_angle < 0.0)
		current_motor_angle = D_PI + current_motor_angle; // D_PI - |current_motor_angle|
	current_motor_speed = (current_motor_angle - last_current_motor_angle) / 0.001;
	last_current_motor_angle = current_motor_angle;
}

void TIM1_IRQHandler(void){
	if(TIM_GetITStatus(TIM2, TIM_IT_Update) == SET){
		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
		
		mainTimFlag = 1;
	}
}
